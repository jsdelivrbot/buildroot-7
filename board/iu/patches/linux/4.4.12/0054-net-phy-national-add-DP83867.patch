From 8724e586e31a6b858102b6ab75dab42140e9b1dd Mon Sep 17 00:00:00 2001
From: Michael Krummsdorf <michael.krummsdorf@tq-group.com>
Date: Mon, 25 Jan 2016 12:23:44 +0100
Subject: [PATCH] net: phy: national: add DP83867

add TI DP83867 gigabit PHY

Signed-off-by: Markus Niebel <Markus.Niebel@tq-group.com>
---
 drivers/net/phy/national.c | 130 ++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 128 insertions(+), 2 deletions(-)

diff --git a/drivers/net/phy/national.c b/drivers/net/phy/national.c
index 0a7b9c7..a94ad88 100644
--- a/drivers/net/phy/national.c
+++ b/drivers/net/phy/national.c
@@ -23,6 +23,7 @@
 #include <linux/ethtool.h>
 #include <linux/phy.h>
 #include <linux/netdevice.h>
+#include <linux/of.h>
 
 #define DEBUG
 
@@ -129,7 +130,122 @@ static int ns_config_init(struct phy_device *phydev)
 	return ns_ack_interrupt(phydev);
 }
 
-static struct phy_driver dp83865_driver[] = { {
+/* DP83867 phy identifier values */
+#define DP83867_PHY_ID	0x2000a230
+
+#define DP83867_INT_CTRL	0x12
+#define DP83867_INT_STATUS	0x13 /* Clear on read */
+
+static int dp83867_ack_interrupt(struct phy_device *phydev)
+{
+	return phy_read(phydev, DP83867_INT_STATUS);
+}
+
+/* PHY Registers */
+#define DP83867_MMD_REGCR			0x0d
+#define DP83867_MMD_REGCR_DEVAD			0x001f
+
+/* Register operations */
+#define DP83867_MMD_REGCR_SET_ADDR		0x0000
+/* Data operations */
+#define DP83867_MMD_REGCR_DATA_NO_POST_INC	0x4000
+#define DP83867_MMD_REGCR_DATA_POST_INC_RW	0x8000
+#define DP83867_MMD_REGCR_DATA_POST_INC_W	0xC000
+
+#define DP83867_MMD_ADDAR			0x0e
+
+#define DP83867_LEDCR1				0x18
+#define DP83867_LEDCR2				0x19
+
+#define DP83867_RGMMIICTL			0x32
+#define DP83867_RGMMIICTL_RX_DELAY		0x01
+#define DP83867_RGMMIICTL_TX_DELAY		0x01
+#define DP83867_RGMMIIDCTL			0x86
+#define DP83867_RGMMIIDCTL_TX_DELAY		0xf0
+#define DP83867_RGMMIIDCTL_RX_DELAY		0x0f
+
+/* Accessors to extended registers*/
+int dp83867_phy_extended_write(struct phy_device *phydev, int regnum,
+			       u16 val)
+{
+	/*select register addr for mmd*/
+	phy_write(phydev, DP83867_MMD_REGCR, DP83867_MMD_REGCR_DEVAD);
+	/*select register for mmd*/
+	phy_write(phydev, DP83867_MMD_ADDAR, regnum);
+	/*setup mode*/
+	phy_write(phydev, DP83867_MMD_REGCR,
+		  (DP83867_MMD_REGCR_DATA_POST_INC_RW |
+		   DP83867_MMD_REGCR_DEVAD));
+	/*write the value*/
+	return	phy_write(phydev, DP83867_MMD_ADDAR, val);
+}
+
+int dp83867_phy_extended_read(struct phy_device *phydev, int regnum)
+{
+	phy_write(phydev, DP83867_MMD_REGCR, DP83867_MMD_REGCR_DEVAD);
+	phy_write(phydev, DP83867_MMD_ADDAR, regnum);
+	phy_write(phydev, DP83867_MMD_REGCR,
+		  (DP83867_MMD_REGCR_DEVAD |
+		   DP83867_MMD_REGCR_DATA_NO_POST_INC));
+	return phy_read(phydev, DP83867_MMD_ADDAR);
+}
+
+static inline int dp83867_ps_to_reg(int ps)
+{
+	return (ps > 4000) ? 0x0f : ((ps < 250) ? 0 : (ps / 250) - 1);
+}
+
+static void dp83867_load_values_from_of(struct phy_device *phydev,
+				       struct device_node *of_node)
+{
+	int rx = -1;
+	int tx = -1;
+	int dm = 0;
+	int rv = 0;
+
+	if (!of_property_read_u32(of_node, "rx-skew-ps", &rx))
+		dm |= DP83867_RGMMIICTL_RX_DELAY;
+
+	if (!of_property_read_u32(of_node, "tx-skew-ps", &tx))
+		dm |= DP83867_RGMMIICTL_TX_DELAY;
+
+	if (dm & DP83867_RGMMIICTL_RX_DELAY)
+		rv |= dp83867_ps_to_reg(rx);
+	if (dm & DP83867_RGMMIICTL_TX_DELAY)
+		rv |= (dp83867_ps_to_reg(tx) << 4);
+
+	dp83867_phy_extended_write(phydev, DP83867_RGMMIIDCTL, rv);
+	rv = dp83867_phy_extended_read(phydev, DP83867_RGMMIICTL);
+	if (rv != -1) {
+		rv &= ~(DP83867_RGMMIICTL_TX_DELAY |
+			DP83867_RGMMIICTL_RX_DELAY);
+		rv |= dm;
+		dp83867_phy_extended_write(phydev, DP83867_RGMMIICTL, rv);
+	}
+
+	if (!of_property_read_u32(of_node, "led-cfg1", &rv))
+		phy_write(phydev, DP83867_LEDCR1, rv);
+	if (!of_property_read_u32(of_node, "led-cfg2", &rv))
+		phy_write(phydev, DP83867_LEDCR2, rv);
+}
+
+static int dp83867_config_init(struct phy_device *phydev)
+{
+	struct device *dev = &phydev->dev;
+	struct device_node *of_node = dev->of_node;
+
+	if (!of_node && dev->parent->of_node)
+		of_node = dev->parent->of_node;
+
+
+	dp83867_ack_interrupt(phydev);
+	dp83867_load_values_from_of(phydev, of_node);
+
+	return 0;
+}
+
+static struct phy_driver national_phy_driver[] = {
+{
 	.phy_id = DP83865_PHY_ID,
 	.phy_id_mask = 0xfffffff0,
 	.name = "NatSemi DP83865",
@@ -141,9 +257,18 @@ static struct phy_driver dp83865_driver[] = { {
 	.ack_interrupt = ns_ack_interrupt,
 	.config_intr = ns_config_intr,
 	.driver = {.owner = THIS_MODULE,}
+}, {
+	.phy_id = DP83867_PHY_ID,
+	.phy_id_mask = 0xfffffff0,
+	.name = "NatSemi DP83867",
+	.features = PHY_GBIT_FEATURES | SUPPORTED_Pause | SUPPORTED_Asym_Pause,
+	.config_init = dp83867_config_init,
+	.config_aneg = genphy_config_aneg,
+	.read_status = genphy_read_status,
+	.driver = {.owner = THIS_MODULE,}
 } };
 
-module_phy_driver(dp83865_driver);
+module_phy_driver(national_phy_driver);
 
 MODULE_DESCRIPTION("NatSemi PHY driver");
 MODULE_AUTHOR("Stuart Menefy");
@@ -151,6 +276,7 @@ MODULE_LICENSE("GPL");
 
 static struct mdio_device_id __maybe_unused ns_tbl[] = {
 	{ DP83865_PHY_ID, 0xfffffff0 },
+	{ DP83867_PHY_ID, 0xfffffff0 },
 	{ }
 };
 
